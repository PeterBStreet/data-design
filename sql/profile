--The following is equivilant to the headder
ALTER DATABASE yourDataBaseName CHARACTER SET UTF8 COLLATE utf8_unicode_ci;

--Drop all the tables before query use for accurate query results
--Dropping the tables will clear all of the data out the database
DROP TABLE IF EXISTS table1;
DROP TABLE IF EXISTS table2;
DROP TABLE IF EXISTS table3;

--Create table starts new table which is essential for xref query
--Typically this table is the parent table for all subsiquent searches, typically!
--Once the table is created the elements of the table are defined
--Elements define both entities and attributes
--The elements define the column name, datatype, and maxwidth
--The element name should be tablenameDetailedDataDescription
--Additionally the element and mandatory or optional status
--Each element may have a unique name
--Each element may have a string type (binary,char, varchar)
--Each element may have a string size
--Each element may have a string status of "not null" (mandatory) or "null" (optional)
--Each element may or may not be a unique index
--The penultimate step is to define unique index elements
-- If an element has a unique index all of the row data associated with that column must be unique.
--The ultimate step is to define the primary key (logical relationship entity) element all other elements to default to attribute
CREATE TABLE table1 (
	elementtable1NameA BINARY(16) NOT NULL,
	elementtable1NameB BINARY (32),
	elementtable1NameC CHAR(64) NOT NULL,
	elementtable1NameD CHAR(80),
	elementtable1NameE VARCHAR(96) NOT NULL,
	elementtable1NameF VARCHAR(128),
	UNIQUE(elementtable1NameA),
	UNIQUE(elementtable1NameB),
	UNIQUE(elementtable1NameC),
	UNIQUE(elementtable1NameD),
	UNIQUE(elementtable1NameE),
	UNIQUE(elementtable1NameF),
	PRIMARY KEY(elementtable1NameA)
);

--Table 1 descriptions and rules apply to Table 2
--Table 2 has some additional "features"
--Create an index key prior to making a foreign key
--The foreign key CAN NOT be the primary key
--The index helps sql searches find rows important to the query
--Primary keys are automatically indexed
--Keep xtable index keys the same string type and size or the query may have issues
--char and varchar are considered the same string type
--The foreign key creates a relationship between the parent and child tables
--The foreign key denotes that the table is the child
--The foreign key (child)table must have at least one exact match elements/colum with the parent table
--Note how the first clause of the foreign key command does not name the child table only the indexed foreign key element/colum
--Note how the second clause of the foreign key command names the parent table  and the indexed parent table element/colum
--
CREATE TABLE table2 (
	elementtable2NameG BINARY(16) NOT NULL,
	elementtable2NameH BINARY (32),
	elementtable2NameI CHAR(64) NOT NULL,
	elementtable2NameJ CHAR(80),
	elementtable2NameK VARCHAR(96) NOT NULL,
	elementtable2NameL VARCHAR(128),
	UNIQUE(elementtable2NameG),
	UNIQUE(elementtable2NameH),
	UNIQUE(elementtable2NameI),
	UNIQUE(elementtable2NameJ),
	UNIQUE(elementtable2NameK),
	UNIQUE(elementtable2NameL),
	INDEX(elementtable2NameH),
	FOREIGN KEY(elementtable2NameH) REFERENCES table1(elementTable1NameA),
	PRIMARY KEY(elementtable2NameG)
);

-- create the like entity (a weak entity from an m-to-n for profile --> tweet)
CREATE TABLE `like` (
	-- these are still foreign keys
	likeProfileId BINARY(16) NOT NULL,
	likeTweetId BINARY(16) NOT NULL,
	likeDate DATETIME(6) NOT NULL,
	-- index the foreign keys
	INDEX(likeProfileId),
	INDEX(likeTweetId),
	-- create the foreign key relations
	FOREIGN KEY(likeProfileId) REFERENCES profile(profileId),
	FOREIGN KEY(likeTweetId) REFERENCES tweet(tweetId),
	-- finally, create a composite foreign key with the two foreign keys
	PRIMARY KEY(likeProfileId, likeTweetId)
);